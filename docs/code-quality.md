### **Конспект статьи «Чистая архитектура во фронтенде Саши Беспоясова»**

---

## **1. Введение**
Статья рассматривает **чистую архитектуру** (Clean Architecture) во фронтенде, её основные принципы, преимущества и возможные издержки. Описывается подход к проектированию кода и его разбиению на слои с использованием примера интернет-магазина печенья.

- **Цель** – объяснить, как можно применять чистую архитектуру в разработке фронтенда, и показать её практическую реализацию.
- **Формат** – разбор архитектурных принципов с пояснением на конкретном примере.

## **2. Архитектура и дизайн**
Системное проектирование предполагает разбиение системы на составные части таким образом, чтобы их можно было легко собрать обратно и вносить изменения с минимальными трудозатратами.

Ключевые цели архитектурного подхода:
1. **Упрощение работы с кодом** – структура должна позволять легко вносить изменения и расширять функциональность.
2. **Выделение домена** – важная логика отделяется от пользовательского интерфейса и инфраструктуры.
3. **Гибкость и расширяемость** – код должен адаптироваться под новые требования без сложных переделок.

---

## **3. Чистая архитектура**
### **Суть подхода**
Чистая архитектура предлагает делить приложение на **логические слои**, определяя их близость к **предметной области** (домену).  

- В центре находится **домен** – ключевые сущности приложения и их преобразования.
- Чем дальше от центра, тем больше код связан с UI и инфраструктурой.

### **Основные слои**
1. **Доменный слой (Core/Domain)** – хранит бизнес-логику и определения сущностей.
2. **Прикладной слой (Application)** – содержит пользовательские сценарии (юзкейсы).
3. **Слой адаптеров (Adapters)** – занимается взаимодействием с UI и внешними сервисами.

![Диаграмма слоёв](https://bespoyasov.ru/images/notes/clean-architecture-on-frontend/layers-adapters.webp)

---

## **4. Разбор слоёв**
### **Доменный слой**
- Описывает **основные сущности** приложения (например, товары, заказы, корзину).
- Хранит **функции преобразования данных**, независимые от UI и внешних сервисов.
- Примеры:
  - `addProduct(cart, product)` – добавляет товар в корзину.
  - `hasAllergy(user, ingredient)` – проверяет наличие аллергии.

### **Прикладной слой**
- Описывает **юзкейсы** – сценарии, реализующие пользовательские действия.
- Отвечает за координацию процессов между доменом и адаптерами.
- Примеры:
  - `orderProducts()` – оформляет заказ.
  - `authenticateUser()` – выполняет вход пользователя.

### **Слой адаптеров**
- Преобразует API **внешних сервисов** под требования приложения.
- Делится на два типа:
  - **Управляющие (Driving Adapters)** – обрабатывают входные данные (например, UI).
  - **Управляемые (Driven Adapters)** – взаимодействуют с инфраструктурой (например, API-сервером).

---

## **5. Правило зависимостей**
В чистой архитектуре действует **жёсткое правило зависимостей**:
> Внешние слои **могут зависеть** от внутренних, но не наоборот.

- Доменный слой **не должен зависеть** от прикладного или адаптеров.
- Нарушение правила приводит к:
  - Циклическим зависимостям.
  - Сложной тестируемости.
  - Хрупкости кода.

![Зависимости между слоями](https://bespoyasov.ru/images/notes/clean-architecture-on-frontend/hex-pie.webp)

---

## **6. Преимущества чистой архитектуры**
1. **Обособленный домен** – основная логика приложения не зависит от UI и инфраструктуры.
2. **Независимые юзкейсы** – сценарии остаются неизменными при изменении внешних сервисов.
3. **Гибкость в выборе инструментов** – можно легко менять базы данных, платежные системы, UI-фреймворки.

---

## **7. Издержки чистой архитектуры**
1. **Затраты времени** – требуется дополнительное время на проектирование и реализацию адаптеров.
2. **Избыточность** – для небольших проектов может оказаться неоправданно сложной.
3. **Рост объёма кода** – увеличивается количество файлов и слоёв, усложняется отладка.

### **Как уменьшить издержки?**
- Выделять **доменный слой** в любом случае.
- Соблюдать **правило зависимостей**, не привязывая домен к UI или API.
- Использовать **упрощённую архитектуру** в небольших проектах.

---

## **8. Пример проектирования интернет-магазина печенья**
### **Функциональные требования**
- Пользователь может заказывать печенье.
- Оплата выполняется через сторонний сервис.
- Авторизация требуется для оформления заказа.

### **Разбиение на слои**
1. **Доменный слой**:
   - **Сущности**: `User`, `Product`, `Cart`, `Order`.
   - **Функции**: `addProduct()`, `calculateTotal()`, `hasAllergy()`.

2. **Прикладной слой**:
   - **Юзкейсы**: `orderProducts()`, `authenticateUser()`, `getCartItems()`.

3. **Слой адаптеров**:
   - **UI** – обработка взаимодействия с пользователем.
   - **API** – запросы к серверу.
   - **Storage** – работа с локальным хранилищем.

---

## **9. Кодовая структура**
Для разделения логики на слои можно использовать следующую структуру:

```
src/
|_ domain/         # Доменный слой
  |_ user.ts
  |_ product.ts
  |_ cart.ts
  |_ order.ts
|_ application/    # Прикладной слой (юзкейсы)
  |_ addToCart.ts
  |_ authenticate.ts
  |_ orderProducts.ts
|_ services/       # Адаптеры (API, UI, storage)
  |_ api.ts
  |_ store.tsx
  |_ authAdapter.ts
  |_ paymentAdapter.ts
|_ ui/             # UI-фреймворк (React/Vue)
```

---

## **10. Написание доменных сущностей**
Пример **типа пользователя**:

```typescript
export type User = {
  id: string;
  name: string;
  email: string;
  preferences: string[];
  allergies: string[];
};
```

Пример **типа товара**:

```typescript
export type Product = {
  id: string;
  title: string;
  price: number;
  ingredients: string[];
};
```

Пример **типа заказа**:

```typescript
export type Order = {
  user: string;
  cart: Cart;
  created: string;
  status: "new" | "completed";
  total: number;
};
```

---

## **11. Реализация бизнес-логики**
Пример **функции добавления товара в корзину**:

```typescript
export function addProduct(cart: Cart, product: Product): Cart {
  return { ...cart, products: [...cart.products, product] };
}
```

Пример **проверки наличия аллергии**:

```typescript
export function hasAllergy(user: User, ingredient: string): boolean {
  return user.allergies.includes(ingredient);
}
```

---

## **12. Итог**
### **Когда стоит применять чистую архитектуру?**
✔ Если проект **крупный** и планируется долгосрочная поддержка.  
✔ Если важна **гибкость** и возможность менять UI-фреймворк или API без серьёзных изменений.  
✔ Если приоритет – **тестируемость** и **понятная структура кода**.

### **Когда можно отказаться от неё?**
❌ Если проект **маленький** и его не планируется масштабировать.  
❌ Если архитектура усложняет разработку без видимой пользы.

---

## **Заключение**
Чистая архитектура – это мощный инструмент для создания **гибких и легко поддерживаемых** приложений. Однако её полная реализация не всегда оправдана, особенно в небольших проектах. Основные принципы можно применять **в упрощённом виде**, выделяя **домен** и контролируя **зависимости**.
